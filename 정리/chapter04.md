# Chpater 04  자바가 확장한 객체 지향 🚀
___
 
## > 2021.11.09 Chapter 4 ##

## 정리 ##

- ### 목표 ###
    1. 자바가 객체 지향을 확장하기 위해 사용하는 키워드와 개념을 이해할 수 있다.

---

- ### abstract 키워드 - 추상메소드와 추상 클래스 ###
    - 추상메소드
        - 선언부는 있지만 구현부가 없는 메소드
        - 왜 필요하고 왜 사용할까??
            1. 제3자가 실수로 만들지 않아야 할 객체를 만들 경우
                - 컴파일 시점에서 에러가 발생하므로 빌드 이전에 방지할 수 있다.
            2. 여러 하위 클래스에 적용하기 위해 상위 클래스에서 메소드 클래스가 필요할 경우
                - 추상 메소드를 통해 하위 클래스에게 메소드에 대한 오버라이딩을 강제화 할 수 있다.

        - 요약
            - 추상 클래스로는 new 키워드 및 인스턴스를 사용할 수 없다.
            - 하위 클래스에 메소드에 대한 오버라이딩을 강제화 한다.
            - 추상 메소드가 단 한개 포함하더라도 해당 클래스는 추상 클래스여야 한다.

---
- ### 생성자 ###
    - 클래스의 인스턴스, 객체를 생성할 때 new 키워드를 사용한다.
    - 생성자 또한 **메소드**이며, 객체 생성자 메소드라고 한다.
        - 이러한 객체 생성자 메소드, 즉 생성자는 기본적으로 Java가 자동으로 만들어 준다.
    ```java
        public class Ex{
            public static void main(String[] args){
                동물 참새 = new 동물("Chamsae");
                동물 까치 = new 동물();
            }
        }
    ```

    - 위와 같은 경우 컴파일 에러가 발생한다.
        - 인자가 있는 생성자를 이미 만들었기 때문에 Java가 자동적으로 기본 생성자를 만들어 주지 않는다. 즉, 우리가 직접 기본 생성자를 만들어야 한다.
    
    - 요약
        - 생성자 == 객체 생성자 메소드
        - 인자가 있는 생성자를 만들었을 경우 따로 기본 생성자를 만들어야 한다.

- ### static 블록 ###
    - 객체 멤버는 클래스가 static 영역에 자리 잡은 후에 객체 생성자를 통해 **힙**에 생성된다.
    - 그러므로, static 블록을 실행되고 있을 때에는 객체가 존재하지 않기 때문에 static 블록에서 객체 멤버에 접근을 할 수 없는 것이다.

    ``` java
        public class StaticEx{
            static{
                System.out.println("여기는 static 블록!");
            }
        }

        public class Ex{
            public static void main(String[] args){
                System.out.println("여기는 main 메소드!");
                StaticEx staticEx = new StaticEx();
                StaticEx staticExTemp = new StaticEx();
            }
        }
    ```

    - 위 코드를 실행하더라도 "여기는 static 블록!"이라는 문구는 단 한번 출력이 된다.
        - 위와 관련하여 클래스 정보는 해당 클래스가 맨 처음 사용될 때 T 메모리의 static 영역에 로딩되며, 이때 단 한번 해당 클래스의 static 블록이 실행된다. 
        - 또한, 클래스가 제일 처음 사용되는 경우는 아래 세가지이다.
            1. 클래스의 정적 속성을 사용할 때
            2. 클래스의 정적 메소드를 사용할 때
            3. 클래스의 인스턴스를 최초로 만들 때

    - 그렇다면, 왜 클래스의 정보가 T 메모리의 static 영역에 로딩하지 않고 해당 클래스가 처음 사용될 때 로딩되는 것인가?
        - 스택틱 영역도 메모리이기 때문이다.
        - 메모리는 최대한 늦게 사용을 시작하고 최대한 빨리 반환하는 것이 정석이기 때문이다.

- ### final 키워드 ###
    ```java
    public final class 동물{

    }
    ```
    - 클래스에 'final' 키워드를 사용할 경우, 상속을 허락하지 않겠다는 의미이다.

    ```java
    final static int 숫자 = 1;
    ```
    - 이렇게 변수에 사용할 경우, 변경이 불가능한 상수로 만들수 있다.

    ```java
    final void 코딩하다(){
        System.out.println("코딩을 하자!");
    }
    ```
    - 메소드에 사용할 경우에는 오버라이딩을 할 수 없다는 의미이다.

- ### instanceOf 연산자 ###
    - 객체가 특정 클래스의 인스턴스인지 물어보는 연산자이다.

    - 상위클래스 : 동물
    - 하위클래스 : 참새 / 강아지 / 고양이

    ```java
        참새 instanceOf(동물);
        강아지 instanceOf(동물);
        고양이 instanceOf(동물);
    ```
    - 위 예시의 결과는 모두 true이다. 
    - instanceOf()는 객체 참조의 변수 타입이 아닌 실제 객체의 타입에 의해 처리하기 때문에 이를 유의해야한다.
    - 이는 인터페이스의 구현 관계에도 똑같이 적용된다.

    - 만약, instanceOf()가 코드 상에 있다면, LSP 원칙을 어기고 있지 않은지 확인해야 한다.
        - [관련 링크](https://flowingmooon.tistory.com/32)

- ### package 키워드 ###
    - 똑같은 클래스명이 생성되더라도 package가 구분점이 되어 줄 수 있다.
    - 네임스페이스(이름공간)를 만들어준다.

- ### interface 키워드와 implements 키워드 ###
    - 인터페이스는 추상 메소드와 정적 상수만 가질 수 있기에 public, abstract등을 붙이지 않아도 자동으로 Java가 붙여준다.
    - 하지만, 좀 더 좋은 코드에 가까운 것은 `public, abstract, final`등의 키워드를 붙여주는 것이다. 이는 좀 더 직관적인 효과를 가져다 준다.


- ### this 키워드 ###
    - 객체 자기 자신을 지칭할 때 사용하는 키워드이다.

    - EX
        - 지역변수 var = 10;
        - 객체변수 var = 20;

        - 이 상황에서 var 변수를 출력하면 어떤 것이 출력 될까?
            - 10이 출력된다.
            - 이름이 같을 경우, 지역 변수가 우선되기 때문이다.
        
        - 만약 20을 출력하고 싶다면?
            - this 키워드를 이용해서 출력해야 한다.
            - this.var

- ### super 키워드 ###
    - super는 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드이다.
    - 상위의 상위 인스턴스에는 접근이 불가능하다.(super.super.~(x))

            