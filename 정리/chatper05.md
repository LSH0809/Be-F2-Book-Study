# Chpater 05  객체 지향 설계 5원칙 - SOLID 🚀
___
 
## > 2021.11.12 Chapter 5 ##

## 정리 ##

- ### 목표 ###
    1. 객체 지향 언어를 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 방법이나 원칙을 이해할 수 있다.

---

- ### SRP - 단일 책임 원칙 ###
   > 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다 - 로버트 C.마틴
   - 위의 말을 곧이 곧대로 받아들이려면, 쉽지 않다.
   - 그러므로, 이렇게 이해해보자. 클래스, 메소드 , 패키지 등에 각각 하나의 역할과 책임만 갖게 하는 것이다.
   - SRP를 위배하는 증거중 하나가 분기 처리를 위한 if문을 작성하는 것이다. 아래는 메소드에 대한 SRP위배에 대한 예시이다.
   ```java
   class 강아지{
       final static Boolean 수컷 = true;
       final static Boolean 암컷 = false;
       Boolean 성별;

       void 소변보다(){
           if(this.성별 == 수컷){
               // 한쪽 다리를 들고 소변을 본다.
           }else{
               // 뒷다리 두개를 굽혀 앉은 자세로 소변을 본다.
           }
       }
   }
   ```

   - 이러한 예시를 아래처럼 추상클래스를 통해 SRP에 위배되지않는 형식으로 고칠 수 있다.
   ```java
   abstract class 강아지{
       abstract void 소변보다()
   }

   class 수컷강아지 extends 강아지{
       void 소변보다(){
           // 한쪽 다리를 들고 소변을 본다.
       }
   }

   class 암컷강아지 extends 강아지{
       void 소변보다(){
           // 뒷다리 두개를 굽혀 앉은 자세로 소변을 본다.
       }
   }
   ```

- ### OCP - 개방 폐쇄 원칙 ###
    > 소프트웨어 엔티티는 확장에 대해서는 열려있어야 하지만, 변경에 대해서는 닫혀있어야 한다. - 로버트 C.마틴
    - 위의 말도 그대로 받아들이기에는 100% 이해가 되지 않는다. 그러므로 의역을 해보면 아래와같다.
    > 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀있어야 한다.
    - 이를 지킬 경우 **유연성, 재사용성, 유지보수성**이라는 장점이 있다.

    - 대표적인 예시는 JDBC가 있다.
    - ![image](https://user-images.githubusercontent.com/73347933/141425055-98ea43e2-abcd-4fd3-9ac3-a99e39c3cd28.png)
    - DB가 MySQL을 사용하든, MS-SQL을 사용하든 우리는 JDBC API를 통해서 설정을 하기 때문에 이외의 부분에 변경을 할 필요가 없다.
    - 즉, 상위 클래스 또는 인터페이스를 중간에 두면서 우리는 변화에는 닫혀있고 확장에는 열려있는 설계를 할 수 있다.

- ### LSP - 리스코프 치환 원칙 ###
    > 서브 타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다. - 로버트 C.마틴
    - 여기서 서브 타입은 하위클래스, 기반타입은 상위클래스로 이해하면 좀 더 이해가 될 수 있을 것이다.
    > 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.
    - 즉, 하위클래스가 상위클래스의 역할을 할 수 있으면 문제가 없다는 것이다. 

    - 여기서는 이전에 공부한 상속에 대한 개념을 다시 한번 짚고 가는 것이 좋을 것같다. 
        - 객체 지향에서의 상속은 조직도나 계층도가 아닌 분류도가 되어야 한다. 
        <br>
        - ![image](https://user-images.githubusercontent.com/73347933/141425988-c685aae2-bdfe-477a-9bc7-b1d8c358a16f.png)
        <br>
        - 이는 대표적인 예제 그림이다.
        - 박쥐에게 포유류의 역할을 부여할 수 있는가? 있다. 그렇다면, 포유류에게 동물의 역할을 부여할 수 있는가? 있다. 즉, 이처럼 상위 클래스의 역할을 하위 클래스에 부여했을 때 문제가 없어야 한다는 의미이다.


- ### ISP - 인터페이스 분리 원칙 ###
    > 클라이언트는 자신이 사용하지 않는 메소드에 의존관계를 맺으면 안된다 - 로버트 C.마틴
    - 이는 SRP와 해결하려는 문제가 같은 맥락이다.
    - SRP의 경우, 단일 객체에게 여러 역할이 맺어져 있어서 이를 각각의 객체로 분리한다는 개념이었다면, 단일객체에 인터페이스로 여러 역할을 부여하는 것이다. 
    <br>
    - ![image](https://user-images.githubusercontent.com/73347933/141427126-eaeaf12f-2226-46b9-b7fe-73050932228e.png)
    <br>
    - 이때, 신경 써야할 부분이 하나 있다. 그것은 **'인터페이스 최소주의 원칙'**이다.
    - 인터페이스 최소주의 원칙은, 인터페이스를 통해 메소드를 외부에 제공할 때는 최소한의 메소드만 제공하라는 것이다.
    - 공통된 부분의 메소드는 **추상메소드**를 통해 구현할 수 있다. 

- ### DIP - 의존 역전 원칙 ###
    > 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
    > 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
    > 자주 변경되는 구체 클래스에 의존하지 마라. - 로버트 C.마틴

    - 이는 이렇게 받아들일 수 있다.
        > 자신보다 변하기 쉬운 것에 의존하지 마라.
    <br>
    - ![image](https://user-images.githubusercontent.com/73347933/141430488-fb45b000-ee2b-4db4-9492-a0cb7d1a8dbc.png)
    <br>
    - 위 그림처럼, 철학책이라는 인터페이스가 중간에 있으면서, 구현체들이 추상화된 인터페이스에 의존을 하고 있다. 
    - 정리를 해보자면, 아래와 같다.
    - 상위 클래스일수록, 인터페이스일수록, 추상클래스일수록 변하지 않을 가능성이 높기에 하위클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상클래스를 통해 의존하라는 것이다.

- ### SoC ###
    - 관심사의 분리라는 의미를 가지고 있다.
    - 관심이 같은 것끼리는 하나의 객체로 모으고, 관심사가 다를 경우에는 따로 분리하여 서로 영향을 주고 받지 않도록 하는 것이다.
    - 이렇게 SoC를 적용하다보면 자연스레 SOLID 원칙을 적용할 수 있다.
        - SOLID 원칙을 적용하다보면 소스파일의 개수도 많아질 수 있지만, 이렇게 많아질 경우, 더욱 잘 표현되고, 유지보수에 편리하다라는 장점이 있다. 